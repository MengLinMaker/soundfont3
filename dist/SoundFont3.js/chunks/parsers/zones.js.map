{"version":3,"file":"zones.js","sources":["../../../../src/chunks/parsers/zones.ts"],"sourcesContent":["import { SF2Chunk } from '../../chunk'\nimport { ParseError } from '../../riff'\nimport { SF_BAG_SIZE } from '../../constants'\nimport {\n  Generator,\n  GeneratorType,\n  Modulator,\n  Zone,\n  ZoneItems,\n  ZoneItemsWithReference,\n  ZoneMap\n} from '../../types'\n\n/**\n * Get the preset or instrument zones from a chunk.\n *\n * @param {SF2Chunk} chunk - The input chunk\n * @param {string} type - The type of chunk ('pbag' or 'ibag')\n */\nexport const getZones = (chunk: SF2Chunk, type: 'pbag' | 'ibag'): Zone[] => {\n  if (chunk.id !== type) {\n    throw new ParseError('Unexpected chunk ID', `'${type}'`, `'${chunk.id}'`)\n  }\n\n  if (chunk.length % SF_BAG_SIZE) {\n    throw new ParseError(`Invalid size for the '${type}' sub-chunk`)\n  }\n\n  return chunk.iterate<Zone>((iterator) => ({\n    generatorIndex: iterator.getInt16(),\n    modulatorIndex: iterator.getInt16()\n  }))\n}\n\n/**\n * Get all modulators, generators and the instrument (for presets) or sample (for instruments) in a\n * preset or instrument.\n *\n * @template T\n * @template R\n * @param {T} headers - The preset or instrument headers\n * @param {Zone[]} zones - All zones for the preset or instrument\n * @param {Modulator[]} itemModulators - All modulators for the preset or instrument\n * @param {Generator[]} itemGenerators - All generators for the preset or instrument\n * @param {R[]} references - The instruments or samples to reference in the zone\n * @param {GeneratorType} referenceType - The generator type to reference it by\n */\nexport const getItemsInZone = <T extends { bagIndex: number }, R>(\n  headers: T[],\n  zones: Zone[],\n  itemModulators: Modulator[],\n  itemGenerators: Generator[],\n  references: R[],\n  referenceType: GeneratorType\n): { header: T; zones: ZoneItemsWithReference<R>[]; globalZone?: ZoneItems }[] => {\n  const items: { header: T; zones: ZoneItemsWithReference<R>[]; globalZone?: ZoneItems }[] = []\n\n  for (let i = 0; i < headers.length; i++) {\n    const header = headers[i]\n    const next = headers[i + 1]\n\n    const start = header.bagIndex\n    const end = next ? next.bagIndex : zones.length\n\n    const zoneItems: ZoneItemsWithReference<R>[] = []\n    let globalZone\n    for (let j = start; j < end; j++) {\n      const modulators = getModulators(j, zones, itemModulators)\n      const generators = getGenerators(j, zones, itemGenerators)\n\n      const keyRange =\n        generators[GeneratorType.KeyRange] && generators[GeneratorType.KeyRange]!.range\n      const referenceId = generators[referenceType]\n      if (!referenceId) {\n        if (j - start === 0) {\n          // first item without reference = global zone\n          // Spec 7.3: If a preset has more than one zone, the first zone may be a global zone.\n          // A global zone is determined by the fact that the last generator in the list is not an Instrument generator.\n          // Spec 7.9: \"Unless the zone is a global zone, the last generator in the list is a “sampleID” generator\"\n          globalZone = {\n            keyRange,\n            modulators,\n            generators\n          }\n        }\n        continue\n      }\n\n      const reference = references[referenceId.value!]\n      if (!reference) {\n        continue\n      }\n\n      zoneItems.push({\n        keyRange,\n        modulators,\n        generators,\n        reference\n      })\n    }\n\n    items.push({\n      header,\n      globalZone,\n      zones: zoneItems\n    })\n  }\n\n  return items\n}\n\n/**\n * Get all modulators from a zone, based on the index. The end index is the modulator index of the\n * next zone, or the total zone length if the current zone is the last one.\n *\n * @param {number} index - The index\n * @param {Zone[]} zones - ALl zones for the preset or instrument\n * @param {Modulator[]} modulators - All modulators for the preset or instrument\n */\nconst getModulators = (\n  index: number,\n  zones: Zone[],\n  modulators: Modulator[]\n): ZoneMap<Modulator> => {\n  const zone = zones[index]\n  const next = zones[index + 1]\n\n  const start = zone.modulatorIndex\n  const end = next ? next.modulatorIndex : zones.length\n\n  return getZone(start, end, modulators)\n}\n\n/**\n * Get all generators from a zone, based on the index. The end index is the generators index of the\n * next zone, or the total zone length if the current zone is the last one.\n *\n * @param {number} index - The index\n * @param {Zone[]} zones - ALl zones for the preset or instrument\n * @param {Generator[]} generators - All generators for the preset or instrument\n */\nconst getGenerators = (\n  index: number,\n  zones: Zone[],\n  generators: Generator[]\n): ZoneMap<Generator> => {\n  const zone = zones[index]\n  const next = zones[index + 1]\n\n  const start = zone.generatorIndex\n  const end = next ? next.generatorIndex : zones.length\n\n  return getZone(start, end, generators)\n}\n\n/**\n * Returns all modulators or generators as a key-value object, where the key is the `GeneratorType`\n * of the modulator or generator.\n *\n * @template T\n * @param {number} start - The start index\n * @param {number} end - The end index\n * @param {T[]} items - The modulators or generators\n */\nconst getZone = <T extends { id: GeneratorType }>(\n  start: number,\n  end: number,\n  items: T[]\n): { [key in GeneratorType]?: T } => {\n  const itemsObject: ZoneMap<T> = {}\n\n  for (let i = start; i < end; i++) {\n    const item = items[i]\n    if (item) {\n      itemsObject[item.id] = item\n    }\n  }\n\n  return itemsObject\n}\n"],"names":["getModulators","index","zones","modulators","zone","next","start","modulatorIndex","end","length","getZone","getGenerators","generators","generatorIndex","items","itemsObject","i","item","id","headers","itemModulators","itemGenerators","references","referenceType","header","bagIndex","zoneItems","globalZone","j","keyRange","GeneratorType","KeyRange","range","referenceId","reference","value","push","chunk","type","ParseError","SF_BAG_SIZE","iterate","iterator","getInt16"],"mappings":"iKAmBa,MAoGPA,EAAgB,CACpBC,EACAC,EACAC,KAEM,MAAAC,EAAOF,EAAMD,GACbI,EAAOH,EAAMD,EAAQ,GAErBK,EAAQF,EAAKG,eACbC,EAAMH,EAAOA,EAAKE,eAAiBL,EAAMO,OAExC,OAAAC,EAAQJ,EAAOE,EAAKL,EAAU,EAWjCQ,EAAgB,CACpBV,EACAC,EACAU,KAEM,MAAAR,EAAOF,EAAMD,GACbI,EAAOH,EAAMD,EAAQ,GAErBK,EAAQF,EAAKS,eACbL,EAAMH,EAAOA,EAAKQ,eAAiBX,EAAMO,OAExC,OAAAC,EAAQJ,EAAOE,EAAKI,EAAU,EAYjCF,EAAU,CACdJ,EACAE,EACAM,KAEA,MAAMC,EAA0B,CAAA,EAEhC,IAAA,IAASC,EAAIV,EAAOU,EAAIR,EAAKQ,IAAK,CAC1B,MAAAC,EAAOH,EAAME,GACfC,IACUF,EAAAE,EAAKC,IAAMD,EAE3B,CAEO,OAAAF,CAAA,yBAnIqB,CAC5BI,EACAjB,EACAkB,EACAC,EACAC,EACAC,KAEA,MAAMT,EAAqF,GAE3F,IAAA,IAASE,EAAI,EAAGA,EAAIG,EAAQV,OAAQO,IAAK,CACjC,MAAAQ,EAASL,EAAQH,GACjBX,EAAOc,EAAQH,EAAI,GAEnBV,EAAQkB,EAAOC,SACfjB,EAAMH,EAAOA,EAAKoB,SAAWvB,EAAMO,OAEnCiB,EAAyC,GAC3C,IAAAC,EACJ,IAAA,IAASC,EAAItB,EAAOsB,EAAIpB,EAAKoB,IAAK,CAChC,MAAMzB,EAAaH,EAAc4B,EAAG1B,EAAOkB,GACrCR,EAAaD,EAAciB,EAAG1B,EAAOmB,GAErCQ,EACJjB,EAAWkB,EAAAA,cAAcC,WAAanB,EAAWkB,EAAAA,cAAcC,UAAWC,MACtEC,EAAcrB,EAAWW,GAC/B,IAAKU,EAAa,CACZL,EAAItB,GAAU,IAKHqB,EAAA,CACXE,WACA1B,aACAS,eAGJ,QACF,CAEM,MAAAsB,EAAYZ,EAAWW,EAAYE,OACpCD,GAILR,EAAUU,KAAK,CACbP,WACA1B,aACAS,aACAsB,aAEJ,CAEApB,EAAMsB,KAAK,CACTZ,SACAG,aACAzB,MAAOwB,GAEX,CAEO,OAAAZ,CAAA,mBAzFe,CAACuB,EAAiBC,KACpC,GAAAD,EAAMnB,KAAOoB,EACT,MAAA,IAAIC,EAAAA,WAAW,sBAAuB,IAAID,KAAS,IAAID,EAAMnB,OAGjE,GAAAmB,EAAM5B,OAAS+B,cACjB,MAAM,IAAID,EAAAA,WAAW,yBAAyBD,gBAGzC,OAAAD,EAAMI,SAAeC,IAAc,CACxC7B,eAAgB6B,EAASC,WACzBpC,eAAgBmC,EAASC,cACzB"}