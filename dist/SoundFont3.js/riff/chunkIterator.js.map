{"version":3,"file":"chunkIterator.js","sources":["../../../src/riff/chunkIterator.ts"],"sourcesContent":["import { RIFFChunk } from './riffChunk'\nimport { getStringFromBuffer } from './utils'\n\n/**\n * A utility class to quickly iterate over a buffer.\n */\nexport class ChunkIterator<T> {\n  public readonly target: T[] = []\n  private readonly chunk: RIFFChunk\n  private position: number = 0\n\n  public constructor(chunk: RIFFChunk, start: number = 0) {\n    this.chunk = chunk\n    this.position = start\n  }\n\n  /**\n   * Get the position from the iterator.\n   */\n  public get currentPosition(): number {\n    return this.position\n  }\n\n  /**\n   * Iterate over the chunk.\n   *\n   * @param {Function} callback - The callback that is called every iteration\n   */\n  public iterate(callback: (iterator: ChunkIterator<T>) => T | null) {\n    while (this.position < this.chunk.length) {\n      const object = callback(this)\n      if (object) {\n        this.target.push(object)\n      }\n    }\n  }\n\n  /**\n   * Get a string from the buffer.\n   *\n   * @param {number} length - The length of the string. If no length is specified, a default of 20\n   *   is assumed\n   */\n  public getString(length: number = 20): string {\n    const text = getStringFromBuffer(this.getBuffer(this.position, length))\n    this.position += length\n    return text\n  }\n\n  /**\n   * Get a signed 16-bit integer from the chunk.\n   */\n  public getInt16(): number {\n    return this.chunk.buffer[this.position++] | (this.chunk.buffer[this.position++] << 8)\n  }\n\n  /**\n   * Get a signed 16-bit integer from the chunk in the big-endian format.\n   */\n  public getInt16BE(): number {\n    return (this.getInt16() << 16) >> 16\n  }\n\n  /**\n   * Get an unsigned 32-bit integer from the chunk.\n   */\n  public getUInt32(): number {\n    return (\n      (this.chunk.buffer[this.position++] |\n        (this.chunk.buffer[this.position++] << 8) |\n        (this.chunk.buffer[this.position++] << 16) |\n        (this.chunk.buffer[this.position++] << 24)) >>>\n      0\n    )\n  }\n\n  /**\n   * Get a single byte from the chunk.\n   */\n  public getByte(): number {\n    return this.chunk.buffer[this.position++]\n  }\n\n  /**\n   * Get a signed char from the chunk.\n   */\n  public getChar(): number {\n    return (this.chunk.buffer[this.position++] << 24) >> 24\n  }\n\n  /**\n   * Skip ahead in the buffer.\n   *\n   * @param {number} length\n   */\n  public skip(length: number): void {\n    this.position += length\n  }\n\n  /**\n   * Get a part of the buffer from start to start + length.\n   *\n   * @param {number} start\n   * @param {number} length\n   */\n  private getBuffer(start: number, length: number): Uint8Array {\n    return this.chunk.buffer.subarray(start, start + length)\n  }\n}\n"],"names":["constructor","chunk","start","__publicField","this","position","currentPosition","iterate","callback","length","object","target","push","getString","text","getStringFromBuffer","getBuffer","getInt16","buffer","getInt16BE","getUInt32","getByte","getChar","skip","subarray"],"mappings":"qNAMO,MAKE,WAAAA,CAAYC,EAAkBC,EAAgB,GAJrDC,EAAAC,KAAgB,SAAc,IACbD,EAAAC,KAAA,SACjBD,EAAAC,KAAQ,WAAmB,GAGzBA,KAAKH,MAAQA,EACbG,KAAKC,SAAWH,CAClB,CAKA,mBAAWI,GACT,OAAOF,KAAKC,QACd,CAOO,OAAAE,CAAQC,GACb,KAAOJ,KAAKC,SAAWD,KAAKH,MAAMQ,QAAQ,CAClC,MAAAC,EAASF,EAASJ,MACpBM,GACGN,KAAAO,OAAOC,KAAKF,EAErB,CACF,CAQO,SAAAG,CAAUJ,EAAiB,IAChC,MAAMK,EAAOC,EAAoBA,oBAAAX,KAAKY,UAAUZ,KAAKC,SAAUI,IAExD,OADPL,KAAKC,UAAYI,EACVK,CACT,CAKO,QAAAG,GACE,OAAAb,KAAKH,MAAMiB,OAAOd,KAAKC,YAAeD,KAAKH,MAAMiB,OAAOd,KAAKC,aAAe,CACrF,CAKO,UAAAc,GACG,OAAAf,KAAKa,YAAc,IAAO,EACpC,CAKO,SAAAG,GAEF,OAAAhB,KAAKH,MAAMiB,OAAOd,KAAKC,YACrBD,KAAKH,MAAMiB,OAAOd,KAAKC,aAAe,EACtCD,KAAKH,MAAMiB,OAAOd,KAAKC,aAAe,GACtCD,KAAKH,MAAMiB,OAAOd,KAAKC,aAAe,MACzC,CAEJ,CAKO,OAAAgB,GACL,OAAOjB,KAAKH,MAAMiB,OAAOd,KAAKC,WAChC,CAKO,OAAAiB,GACL,OAAQlB,KAAKH,MAAMiB,OAAOd,KAAKC,aAAe,IAAO,EACvD,CAOO,IAAAkB,CAAKd,GACVL,KAAKC,UAAYI,CACnB,CAQQ,SAAAO,CAAUd,EAAeO,GAC/B,OAAOL,KAAKH,MAAMiB,OAAOM,SAAStB,EAAOA,EAAQO,EACnD"}