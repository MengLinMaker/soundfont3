{"version":3,"file":"parser.js","sources":["../../../src/riff/parser.ts"],"sourcesContent":["import { ParseError } from './parseError'\nimport { getStringFromBuffer } from './utils'\nimport { RIFFChunk } from './riffChunk'\n\n/**\n * Attempts to parse a RIFF file from a raw buffer.\n *\n * @param {Uint8Array} buffer - The input buffer\n */\nexport const parseBuffer = (buffer: Uint8Array): RIFFChunk => {\n  const id = getChunkId(buffer)\n  if (id !== 'RIFF') {\n    throw new ParseError('Invalid file format', 'RIFF', id)\n  }\n\n  const signature = getChunkId(buffer, 8)\n  if (signature !== 'sfbk') {\n    throw new ParseError('Invalid signature', 'sfbk', signature)\n  }\n\n  const newBuffer = buffer.subarray(8)\n  const subChunks = getSubChunks(newBuffer.subarray(4))\n  return new RIFFChunk(id, newBuffer.length, newBuffer, subChunks)\n}\n\n/**\n * Get a RIFF chunk from a buffer.\n *\n * @param {Buffer} buffer - The input buffer\n * @param {number} start - Where to start reading the buffer\n */\nexport const getChunk = (buffer: Uint8Array, start: number): RIFFChunk => {\n  const id = getChunkId(buffer, start)\n  const length = getChunkLength(buffer, start + 4)\n\n  // RIFF and LIST chunks can have sub-chunks\n  let subChunks: RIFFChunk[] = []\n  if (id === 'RIFF' || id === 'LIST') {\n    subChunks = getSubChunks(buffer.subarray(start + 12))\n  }\n\n  return new RIFFChunk(id, length, buffer.subarray(start + 8), subChunks)\n}\n\n/**\n * Get the length of a chunk, based on the RIFF length specifier.\n *\n * @param {Buffer} buffer - The input buffer\n * @param {number} start - Where to start reading the buffer for the length\n */\nexport const getChunkLength = (buffer: Uint8Array, start: number) => {\n  buffer = buffer.subarray(start, start + 4)\n\n  return (buffer[0] | (buffer[1] << 8) | (buffer[2] << 16) | (buffer[3] << 24)) >>> 0\n}\n\n/**\n * Get all sub-chunks in a buffer. This will read until the end of the buffer and return any\n * sub-chunks found in it.\n *\n * @param {Buffer} buffer - The input buffer\n */\nexport const getSubChunks = (buffer: Uint8Array): RIFFChunk[] => {\n  const chunks: RIFFChunk[] = []\n  let index = 0\n\n  while (index <= buffer.length - 8) {\n    const subChunk = getChunk(buffer, index)\n    chunks.push(subChunk)\n\n    index += 8 + subChunk.length\n    index = index % 2 ? index + 1 : index\n  }\n\n  return chunks\n}\n\n/**\n * Get the chunk ID (fourCC) from the buffer. This assumes the fourCC code is formatted as an UTF-8\n * string.\n *\n * @param {Buffer} buffer - The input buffer\n * @param {number} start - Where to start reading the chunk ID from the buffer\n */\nexport const getChunkId = (buffer: Uint8Array, start: number = 0) => {\n  return getStringFromBuffer(buffer.subarray(start, start + 4))\n}\n"],"names":["getChunk","buffer","start","id","getChunkId","length","getChunkLength","subChunks","getSubChunks","subarray","RIFFChunk","chunks","index","subChunk","push","getStringFromBuffer","ParseError","signature","newBuffer"],"mappings":"kGASa,MAsBAA,EAAW,CAACC,EAAoBC,KACrC,MAAAC,EAAKC,EAAWH,EAAQC,GACxBG,EAASC,EAAeL,EAAQC,EAAQ,GAG9C,IAAIK,EAAyB,GAKtB,MAJI,SAAPJ,GAAwB,SAAPA,IACnBI,EAAYC,EAAaP,EAAOQ,SAASP,EAAQ,MAG5C,IAAIQ,EAAAA,UAAUP,EAAIE,EAAQJ,EAAOQ,SAASP,EAAQ,GAAIK,EAAS,EAS3DD,EAAiB,CAACL,EAAoBC,MACjDD,EAASA,EAAOQ,SAASP,EAAOA,EAAQ,IAEzB,GAAMD,EAAO,IAAM,EAAMA,EAAO,IAAM,GAAOA,EAAO,IAAM,MAAS,EASvEO,EAAgBP,IAC3B,MAAMU,EAAsB,GAC5B,IAAIC,EAAQ,EAEL,KAAAA,GAASX,EAAOI,OAAS,GAAG,CAC3B,MAAAQ,EAAWb,EAASC,EAAQW,GAClCD,EAAOG,KAAKD,GAEZD,GAAS,EAAIC,EAASR,OACdO,EAAAA,EAAQ,EAAIA,EAAQ,EAAIA,CAClC,CAEO,OAAAD,CAAA,EAUIP,EAAa,CAACH,EAAoBC,EAAgB,IACtDa,EAAAA,oBAAoBd,EAAOQ,SAASP,EAAOA,EAAQ,gHA5EhCD,IACpB,MAAAE,EAAKC,EAAWH,GACtB,GAAW,SAAPE,EACF,MAAM,IAAIa,EAAAA,WAAW,sBAAuB,OAAQb,GAGhD,MAAAc,EAAYb,EAAWH,EAAQ,GACrC,GAAkB,SAAdgB,EACF,MAAM,IAAID,EAAAA,WAAW,oBAAqB,OAAQC,GAG9C,MAAAC,EAAYjB,EAAOQ,SAAS,GAC5BF,EAAYC,EAAaU,EAAUT,SAAS,IAClD,OAAO,IAAIC,EAAUA,UAAAP,EAAIe,EAAUb,OAAQa,EAAWX,EAAS"}