{"version":3,"file":"toSoundFont2Web.js","sources":["../../../src/write/toSoundFont2Web.ts"],"sourcesContent":["import { SoundFont3 } from '../soundFont3'\nimport { SampleHeader } from '../types'\nimport { writeSoundFont } from './writeSoundFont'\nimport { SoundFont2Raw, concatBuffer } from './utils'\n\nfunction floatTo16BitPCM(input: Float32Array) {\n  const view = new DataView(new ArrayBuffer(input.length * 2))\n  let offset = 0\n  for (let i = 0; i < input.length; i++, offset += 2) {\n    const s = Math.max(-1, Math.min(1, input[i]))\n    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true)\n  }\n  return view.buffer\n}\n\nexport const toSoundFont2Web = async (_soundFont: SoundFont3) => {\n  const soundFont = structuredClone(_soundFont) as never as SoundFont2Raw\n  const soundFontVersion = Number(soundFont.metaData.version)\n  if (soundFontVersion < 3) return _soundFont\n\n  const sampleHeaders: SampleHeader[] = []\n  let sampleBuffer = new Int8Array()\n  let sampleOffset = 0\n  const decode = await import('audio-decode')\n  for (const sample of soundFont.samples) {\n    const audioBuffer = await decode.default(new Int8Array(sample.data).buffer)\n    const wavBuffer = floatTo16BitPCM(audioBuffer.getChannelData(0))\n    const padBuffer = new ArrayBuffer(2 - (wavBuffer.byteLength % 2))\n\n    sample.header.start = sampleOffset\n    sample.header.end = sampleOffset + wavBuffer.byteLength / 2\n    const sampleLen = sample.header.end - sample.header.start\n    const loopLen = sample.header.endLoop - sample.header.startLoop\n    sample.header.endLoop = sampleLen - 128\n    sample.header.startLoop = sampleLen - loopLen - 128\n\n    sampleBuffer = concatBuffer(concatBuffer(sampleBuffer, wavBuffer), padBuffer)\n    sampleOffset += wavBuffer.byteLength / 2 + padBuffer.byteLength\n    sampleHeaders.push(sample.header)\n  }\n  console.info(`Sample size: ${(sampleBuffer.byteLength / 10 ** 6).toFixed(3)} mb`)\n\n  soundFont.metaData.version = '2.04'\n  soundFont.sampleData = new Int16Array(sampleBuffer)\n  soundFont.presetData.sampleHeaders = sampleHeaders\n  return new SoundFont3(new Uint8Array(writeSoundFont(soundFont)))\n}\n"],"names":["floatTo16BitPCM","input","view","DataView","ArrayBuffer","length","offset","i","s","Math","max","min","setInt16","buffer","async","_soundFont","soundFont","structuredClone","Number","metaData","version","sampleHeaders","sampleBuffer","Int8Array","sampleOffset","decode","import","sample","samples","wavBuffer","default","data","getChannelData","padBuffer","byteLength","header","start","end","sampleLen","loopLen","endLoop","startLoop","concatBuffer","push","console","info","toFixed","sampleData","Int16Array","presetData","SoundFont3","Uint8Array","writeSoundFont"],"mappings":"wGAKA,SAASA,EAAgBC,GACjB,MAAAC,EAAO,IAAIC,SAAS,IAAIC,YAA2B,EAAfH,EAAMI,SAChD,IAAIC,EAAS,EACb,IAAA,IAASC,EAAI,EAAGA,EAAIN,EAAMI,OAAQE,IAAKD,GAAU,EAAG,CAC5C,MAAAE,EAAIC,KAAKC,KAAQ,EAAAD,KAAKE,IAAI,EAAGV,EAAMM,KACpCL,EAAAU,SAASN,EAAQE,EAAI,EAAQ,MAAJA,EAAiB,MAAJA,GAAY,EACzD,CACA,OAAON,EAAKW,MACd,yBAE+BC,MAAOC,IAC9B,MAAAC,EAAYC,gBAAgBF,GAE9B,GADqBG,OAAOF,EAAUG,SAASC,SAC5B,EAAU,OAAAL,EAEjC,MAAMM,EAAgC,GAClC,IAAAC,EAAe,IAAIC,UACnBC,EAAe,EACb,MAAAC,QAAeC,OAAO,gBACjB,IAAA,MAAAC,KAAUX,EAAUY,QAAS,CAChC,MACAC,EAAY7B,SADQyB,EAAOK,QAAQ,IAAIP,UAAUI,EAAOI,MAAMlB,SACtBmB,eAAe,IACvDC,EAAY,IAAI7B,YAAY,EAAKyB,EAAUK,WAAa,GAE9DP,EAAOQ,OAAOC,MAAQZ,EACtBG,EAAOQ,OAAOE,IAAMb,EAAeK,EAAUK,WAAa,EAC1D,MAAMI,EAAYX,EAAOQ,OAAOE,IAAMV,EAAOQ,OAAOC,MAC9CG,EAAUZ,EAAOQ,OAAOK,QAAUb,EAAOQ,OAAOM,UAC/Cd,EAAAQ,OAAOK,QAAUF,EAAY,IAC7BX,EAAAQ,OAAOM,UAAYH,EAAYC,EAAU,IAEhDjB,EAAeoB,EAAaA,aAAAA,EAAAA,aAAapB,EAAcO,GAAYI,GACnDT,GAAAK,EAAUK,WAAa,EAAID,EAAUC,WACvCb,EAAAsB,KAAKhB,EAAOQ,OAC5B,CAMA,OALQS,QAAAC,KAAK,iBAAiBvB,EAAaY,WAAa,IAAM,GAAGY,QAAQ,SAEzE9B,EAAUG,SAASC,QAAU,OACnBJ,EAAA+B,WAAa,IAAIC,WAAW1B,GACtCN,EAAUiC,WAAW5B,cAAgBA,EAC9B,IAAI6B,EAAWA,WAAA,IAAIC,WAAWC,EAAAA,eAAepC,IAAW"}