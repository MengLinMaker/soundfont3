{"version":3,"file":"parser.js","sources":["../../../src/riff/parser.ts"],"sourcesContent":["import { ParseError } from './parseError'\nimport { getStringFromBuffer } from './utils'\nimport { RIFFChunk } from './riffChunk'\n\n/**\n * Attempts to parse a RIFF file from a raw buffer.\n *\n * @param {Uint8Array} buffer - The input buffer\n */\nexport const parseBuffer = (buffer: Uint8Array): RIFFChunk => {\n  const id = getChunkId(buffer)\n  if (id !== 'RIFF') {\n    throw new ParseError('Invalid file format', 'RIFF', id)\n  }\n\n  const signature = getChunkId(buffer, 8)\n  if (signature !== 'sfbk') {\n    throw new ParseError('Invalid signature', 'sfbk', signature)\n  }\n\n  const newBuffer = buffer.subarray(8)\n  const subChunks = getSubChunks(newBuffer.subarray(4))\n  return new RIFFChunk(id, newBuffer.length, newBuffer, subChunks)\n}\n\n/**\n * Get a RIFF chunk from a buffer.\n *\n * @param {Buffer} buffer - The input buffer\n * @param {number} start - Where to start reading the buffer\n */\nexport const getChunk = (buffer: Uint8Array, start: number): RIFFChunk => {\n  const id = getChunkId(buffer, start)\n  const length = getChunkLength(buffer, start + 4)\n\n  // RIFF and LIST chunks can have sub-chunks\n  let subChunks: RIFFChunk[] = []\n  if (id === 'RIFF' || id === 'LIST') {\n    subChunks = getSubChunks(buffer.subarray(start + 12))\n  }\n\n  return new RIFFChunk(id, length, buffer.subarray(start + 8), subChunks)\n}\n\n/**\n * Get the length of a chunk, based on the RIFF length specifier.\n *\n * @param {Buffer} buffer - The input buffer\n * @param {number} start - Where to start reading the buffer for the length\n */\nexport const getChunkLength = (buffer: Uint8Array, start: number) => {\n  buffer = buffer.subarray(start, start + 4)\n\n  return (buffer[0] | (buffer[1] << 8) | (buffer[2] << 16) | (buffer[3] << 24)) >>> 0\n}\n\n/**\n * Get all sub-chunks in a buffer. This will read until the end of the buffer and return any\n * sub-chunks found in it.\n *\n * @param {Buffer} buffer - The input buffer\n */\nexport const getSubChunks = (buffer: Uint8Array): RIFFChunk[] => {\n  const chunks: RIFFChunk[] = []\n  let index = 0\n\n  while (index <= buffer.length - 8) {\n    const subChunk = getChunk(buffer, index)\n    chunks.push(subChunk)\n\n    index += 8 + subChunk.length\n    index = index % 2 ? index + 1 : index\n  }\n\n  return chunks\n}\n\n/**\n * Get the chunk ID (fourCC) from the buffer. This assumes the fourCC code is formatted as an UTF-8\n * string.\n *\n * @param {Buffer} buffer - The input buffer\n * @param {number} start - Where to start reading the chunk ID from the buffer\n */\nexport const getChunkId = (buffer: Uint8Array, start: number = 0) => {\n  return getStringFromBuffer(buffer.subarray(start, start + 4))\n}\n"],"names":["parseBuffer","buffer","id","getChunkId","ParseError","signature","newBuffer","subarray","subChunks","getSubChunks","RIFFChunk","length","getChunk","start","getChunkLength","chunks","index","subChunk","push","getStringFromBuffer"],"mappings":"yIASa,MAAAA,EAAeC,IACpB,MAAAC,EAAKC,EAAWF,GACtB,GAAW,SAAPC,EACF,MAAM,IAAIE,EAAW,sBAAuB,OAAQF,GAGhD,MAAAG,EAAYF,EAAWF,EAAQ,GACrC,GAAkB,SAAdI,EACF,MAAM,IAAID,EAAW,oBAAqB,OAAQC,GAG9C,MAAAC,EAAYL,EAAOM,SAAS,GAC5BC,EAAYC,EAAaH,EAAUC,SAAS,IAClD,OAAO,IAAIG,EAAUR,EAAII,EAAUK,OAAQL,EAAWE,EAAS,EASpDI,EAAW,CAACX,EAAoBY,KACrC,MAAAX,EAAKC,EAAWF,EAAQY,GACxBF,EAASG,EAAeb,EAAQY,EAAQ,GAG9C,IAAIL,EAAyB,GAKtB,MAJI,SAAPN,GAAwB,SAAPA,IACnBM,EAAYC,EAAaR,EAAOM,SAASM,EAAQ,MAG5C,IAAIH,EAAUR,EAAIS,EAAQV,EAAOM,SAASM,EAAQ,GAAIL,EAAS,EAS3DM,EAAiB,CAACb,EAAoBY,MACjDZ,EAASA,EAAOM,SAASM,EAAOA,EAAQ,IAEzB,GAAMZ,EAAO,IAAM,EAAMA,EAAO,IAAM,GAAOA,EAAO,IAAM,MAAS,EASvEQ,EAAgBR,IAC3B,MAAMc,EAAsB,GAC5B,IAAIC,EAAQ,EAEL,KAAAA,GAASf,EAAOU,OAAS,GAAG,CAC3B,MAAAM,EAAWL,EAASX,EAAQe,GAClCD,EAAOG,KAAKD,GAEZD,GAAS,EAAIC,EAASN,OACdK,EAAAA,EAAQ,EAAIA,EAAQ,EAAIA,CAClC,CAEO,OAAAD,CAAA,EAUIZ,EAAa,CAACF,EAAoBY,EAAgB,IACtDM,EAAoBlB,EAAOM,SAASM,EAAOA,EAAQ"}