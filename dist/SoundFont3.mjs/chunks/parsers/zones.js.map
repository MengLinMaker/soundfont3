{"version":3,"file":"zones.js","sources":["../../../../src/chunks/parsers/zones.ts"],"sourcesContent":["import { SF2Chunk } from '../../chunk'\nimport { ParseError } from '../../riff'\nimport { SF_BAG_SIZE } from '../../constants'\nimport {\n  Generator,\n  GeneratorType,\n  Modulator,\n  Zone,\n  ZoneItems,\n  ZoneItemsWithReference,\n  ZoneMap\n} from '../../types'\n\n/**\n * Get the preset or instrument zones from a chunk.\n *\n * @param {SF2Chunk} chunk - The input chunk\n * @param {string} type - The type of chunk ('pbag' or 'ibag')\n */\nexport const getZones = (chunk: SF2Chunk, type: 'pbag' | 'ibag'): Zone[] => {\n  if (chunk.id !== type) {\n    throw new ParseError('Unexpected chunk ID', `'${type}'`, `'${chunk.id}'`)\n  }\n\n  if (chunk.length % SF_BAG_SIZE) {\n    throw new ParseError(`Invalid size for the '${type}' sub-chunk`)\n  }\n\n  return chunk.iterate<Zone>((iterator) => ({\n    generatorIndex: iterator.getInt16(),\n    modulatorIndex: iterator.getInt16()\n  }))\n}\n\n/**\n * Get all modulators, generators and the instrument (for presets) or sample (for instruments) in a\n * preset or instrument.\n *\n * @template T\n * @template R\n * @param {T} headers - The preset or instrument headers\n * @param {Zone[]} zones - All zones for the preset or instrument\n * @param {Modulator[]} itemModulators - All modulators for the preset or instrument\n * @param {Generator[]} itemGenerators - All generators for the preset or instrument\n * @param {R[]} references - The instruments or samples to reference in the zone\n * @param {GeneratorType} referenceType - The generator type to reference it by\n */\nexport const getItemsInZone = <T extends { bagIndex: number }, R>(\n  headers: T[],\n  zones: Zone[],\n  itemModulators: Modulator[],\n  itemGenerators: Generator[],\n  references: R[],\n  referenceType: GeneratorType\n): { header: T; zones: ZoneItemsWithReference<R>[]; globalZone?: ZoneItems }[] => {\n  const items: { header: T; zones: ZoneItemsWithReference<R>[]; globalZone?: ZoneItems }[] = []\n\n  for (let i = 0; i < headers.length; i++) {\n    const header = headers[i]\n    const next = headers[i + 1]\n\n    const start = header.bagIndex\n    const end = next ? next.bagIndex : zones.length\n\n    const zoneItems: ZoneItemsWithReference<R>[] = []\n    let globalZone\n    for (let j = start; j < end; j++) {\n      const modulators = getModulators(j, zones, itemModulators)\n      const generators = getGenerators(j, zones, itemGenerators)\n\n      const keyRange =\n        generators[GeneratorType.KeyRange] && generators[GeneratorType.KeyRange]!.range\n      const referenceId = generators[referenceType]\n      if (!referenceId) {\n        if (j - start === 0) {\n          // first item without reference = global zone\n          // Spec 7.3: If a preset has more than one zone, the first zone may be a global zone.\n          // A global zone is determined by the fact that the last generator in the list is not an Instrument generator.\n          // Spec 7.9: \"Unless the zone is a global zone, the last generator in the list is a “sampleID” generator\"\n          globalZone = {\n            keyRange,\n            modulators,\n            generators\n          }\n        }\n        continue\n      }\n\n      const reference = references[referenceId.value!]\n      if (!reference) {\n        continue\n      }\n\n      zoneItems.push({\n        keyRange,\n        modulators,\n        generators,\n        reference\n      })\n    }\n\n    items.push({\n      header,\n      globalZone,\n      zones: zoneItems\n    })\n  }\n\n  return items\n}\n\n/**\n * Get all modulators from a zone, based on the index. The end index is the modulator index of the\n * next zone, or the total zone length if the current zone is the last one.\n *\n * @param {number} index - The index\n * @param {Zone[]} zones - ALl zones for the preset or instrument\n * @param {Modulator[]} modulators - All modulators for the preset or instrument\n */\nconst getModulators = (\n  index: number,\n  zones: Zone[],\n  modulators: Modulator[]\n): ZoneMap<Modulator> => {\n  const zone = zones[index]\n  const next = zones[index + 1]\n\n  const start = zone.modulatorIndex\n  const end = next ? next.modulatorIndex : zones.length\n\n  return getZone(start, end, modulators)\n}\n\n/**\n * Get all generators from a zone, based on the index. The end index is the generators index of the\n * next zone, or the total zone length if the current zone is the last one.\n *\n * @param {number} index - The index\n * @param {Zone[]} zones - ALl zones for the preset or instrument\n * @param {Generator[]} generators - All generators for the preset or instrument\n */\nconst getGenerators = (\n  index: number,\n  zones: Zone[],\n  generators: Generator[]\n): ZoneMap<Generator> => {\n  const zone = zones[index]\n  const next = zones[index + 1]\n\n  const start = zone.generatorIndex\n  const end = next ? next.generatorIndex : zones.length\n\n  return getZone(start, end, generators)\n}\n\n/**\n * Returns all modulators or generators as a key-value object, where the key is the `GeneratorType`\n * of the modulator or generator.\n *\n * @template T\n * @param {number} start - The start index\n * @param {number} end - The end index\n * @param {T[]} items - The modulators or generators\n */\nconst getZone = <T extends { id: GeneratorType }>(\n  start: number,\n  end: number,\n  items: T[]\n): { [key in GeneratorType]?: T } => {\n  const itemsObject: ZoneMap<T> = {}\n\n  for (let i = start; i < end; i++) {\n    const item = items[i]\n    if (item) {\n      itemsObject[item.id] = item\n    }\n  }\n\n  return itemsObject\n}\n"],"names":["getZones","chunk","type","id","ParseError","length","SF_BAG_SIZE","iterate","iterator","generatorIndex","getInt16","modulatorIndex","getItemsInZone","headers","zones","itemModulators","itemGenerators","references","referenceType","items","i","header","next","start","bagIndex","end","zoneItems","globalZone","j","modulators","getModulators","generators","getGenerators","keyRange","GeneratorType","KeyRange","range","referenceId","reference","value","push","index","zone","getZone","itemsObject","item"],"mappings":"iMAmBa,MAAAA,EAAW,CAACC,EAAiBC,KACpC,GAAAD,EAAME,KAAOD,EACT,MAAA,IAAIE,EAAW,sBAAuB,IAAIF,KAAS,IAAID,EAAME,OAGjE,GAAAF,EAAMI,OAASC,EACjB,MAAM,IAAIF,EAAW,yBAAyBF,gBAGzC,OAAAD,EAAMM,SAAeC,IAAc,CACxCC,eAAgBD,EAASE,WACzBC,eAAgBH,EAASE,cACzB,EAgBSE,EAAiB,CAC5BC,EACAC,EACAC,EACAC,EACAC,EACAC,KAEA,MAAMC,EAAqF,GAE3F,IAAA,IAASC,EAAI,EAAGA,EAAIP,EAAQR,OAAQe,IAAK,CACjC,MAAAC,EAASR,EAAQO,GACjBE,EAAOT,EAAQO,EAAI,GAEnBG,EAAQF,EAAOG,SACfC,EAAMH,EAAOA,EAAKE,SAAWV,EAAMT,OAEnCqB,EAAyC,GAC3C,IAAAC,EACJ,IAAA,IAASC,EAAIL,EAAOK,EAAIH,EAAKG,IAAK,CAChC,MAAMC,EAAaC,EAAcF,EAAGd,EAAOC,GACrCgB,EAAaC,EAAcJ,EAAGd,EAAOE,GAErCiB,EACJF,EAAWG,EAAcC,WAAaJ,EAAWG,EAAcC,UAAWC,MACtEC,EAAcN,EAAWb,GAC/B,IAAKmB,EAAa,CACZT,EAAIL,GAAU,IAKHI,EAAA,CACXM,WACAJ,aACAE,eAGJ,QACF,CAEM,MAAAO,EAAYrB,EAAWoB,EAAYE,OACpCD,GAILZ,EAAUc,KAAK,CACbP,WACAJ,aACAE,aACAO,aAEJ,CAEAnB,EAAMqB,KAAK,CACTnB,SACAM,aACAb,MAAOY,GAEX,CAEO,OAAAP,CAAA,EAWHW,EAAgB,CACpBW,EACA3B,EACAe,KAEM,MAAAa,EAAO5B,EAAM2B,GACbnB,EAAOR,EAAM2B,EAAQ,GAErBlB,EAAQmB,EAAK/B,eACbc,EAAMH,EAAOA,EAAKX,eAAiBG,EAAMT,OAExC,OAAAsC,EAAQpB,EAAOE,EAAKI,EAAU,EAWjCG,EAAgB,CACpBS,EACA3B,EACAiB,KAEM,MAAAW,EAAO5B,EAAM2B,GACbnB,EAAOR,EAAM2B,EAAQ,GAErBlB,EAAQmB,EAAKjC,eACbgB,EAAMH,EAAOA,EAAKb,eAAiBK,EAAMT,OAExC,OAAAsC,EAAQpB,EAAOE,EAAKM,EAAU,EAYjCY,EAAU,CACdpB,EACAE,EACAN,KAEA,MAAMyB,EAA0B,CAAA,EAEhC,IAAA,IAASxB,EAAIG,EAAOH,EAAIK,EAAKL,IAAK,CAC1B,MAAAyB,EAAO1B,EAAMC,GACfyB,IACUD,EAAAC,EAAK1C,IAAM0C,EAE3B,CAEO,OAAAD,CAAA"}