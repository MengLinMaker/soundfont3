import{ParseError as e}from"../../riff/parseError.js";import{GeneratorType as t}from"../../types/generator.js";import"../../types/modulator.js";import{SF_GENERATOR_SIZE as s}from"../../constants.js";const r=[t.StartAddrsOffset,t.EndAddrsOffset,t.StartLoopAddrsOffset,t.EndLoopAddrsOffset,t.StartAddrsCoarseOffset,t.EndAddrsCoarseOffset,t.StartLoopAddrsCoarseOffset,t.KeyNum,t.Velocity,t.EndLoopAddrsCoarseOffset,t.SampleModes,t.ExclusiveClass,t.OverridingRootKey],d=[t.Unused1,t.Unused2,t.Unused3,t.Unused4,t.Reserved1,t.Reserved2,t.Reserved3],n=[t.KeyRange,t.VelRange],o=(o,f)=>{if(o.id!==f)throw new e("Unexpected chunk ID",`'${f}'`,`'${o.id}'`);if(o.length%s)throw new e(`Invalid size for the '${f}' sub-chunk`);return o.iterate((e=>{const s=e.getInt16();return t[s]?"pgen"===f&&r.includes(s)||"igen"===f&&d.includes(s)?null:n.includes(s)?{id:s,range:{lo:e.getByte(),hi:e.getByte()}}:{id:s,value:e.getInt16BE()}:null}))};export{o as getGenerators};
//# sourceMappingURL=generators.js.map
