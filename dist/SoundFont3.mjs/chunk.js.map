{"version":3,"file":"chunk.js","sources":["../../src/chunk.ts"],"sourcesContent":["import { ParseError, RIFFChunk } from './riff'\nimport { MetaData, PresetData } from './types'\nimport { SF_INFO_CHUNKS_ID, SF_VERSION_LENGTH } from './constants'\nimport {\n  getGenerators,\n  getInstrumentHeaders,\n  getModulators,\n  getPresetHeaders,\n  getSampleHeaders,\n  getZones\n} from './chunks'\n\nexport class SF2Chunk extends RIFFChunk {\n  /**\n   * All sub-chunks of this `SF2Chunk` as `SF2Chunk`.\n   */\n  public override readonly subChunks: SF2Chunk[]\n\n  public constructor(chunk: RIFFChunk) {\n    super(chunk.id, chunk.length, chunk.buffer, chunk.subChunks)\n\n    this.subChunks = chunk.subChunks.map((subChunk) => new SF2Chunk(subChunk))\n  }\n\n  /**\n   * Get meta data from the chunk. This assumes the chunk is a LIST chunk, containing INFO\n   * sub-chunks.\n   */\n  private validMetaDataChunkId(): boolean {\n    return this.id === 'LIST'\n  }\n\n  public getMetaData(): MetaData {\n    if (!this.validMetaDataChunkId()) {\n      throw new ParseError('Unexpected chunk ID', `'LIST'`, `'${this.id}'`)\n    }\n\n    const info = this.subChunks.reduce<{ [key in SF_INFO_CHUNKS_ID]?: string }>((target, chunk) => {\n      if (chunk.id === 'ifil' || chunk.id === 'iver') {\n        // ifil and iver length must be 4 bytes\n        if (chunk.length !== SF_VERSION_LENGTH) {\n          throw new ParseError(`Invalid size for the '${chunk.id}' sub-chunk`)\n        }\n        target[chunk.id as SF_INFO_CHUNKS_ID] = `${chunk.getInt16()}.${chunk.getInt16(2)}`\n      } else {\n        target[chunk.id as SF_INFO_CHUNKS_ID] = chunk.getString()\n      }\n\n      return target\n    }, {})\n\n    if (!info.ifil) {\n      throw new ParseError(`Missing required 'ifil' sub-chunk`)\n    }\n\n    if (!info.INAM) {\n      throw new ParseError(`Missing required 'INAM' sub-chunk`)\n    }\n\n    return {\n      version: info.ifil,\n      soundEngine: info.isng || 'EMU8000',\n      name: info.INAM,\n      rom: info.irom,\n      romVersion: info.iver,\n      creationDate: info.ICRD,\n      author: info.IENG,\n      product: info.IPRD,\n      copyright: info.ICOP,\n      comments: info.ICMT,\n      createdBy: info.ISFT\n    }\n  }\n\n  /**\n   * Get the sample data as a unsigned 8-bit buffer from the chunk. This assumes the chunk is a\n   * LIST chunk containing a smpl sub-chunk.\n   */\n  public getSampleData(): Uint8Array {\n    if (!this.validMetaDataChunkId()) {\n      throw new ParseError('Unexpected chunk ID', `'LIST'`, `'${this.id}'`)\n    }\n\n    const sampleChunk = this.subChunks[0]\n    if (sampleChunk.id !== 'smpl') {\n      throw new ParseError('Invalid chunk signature', `'smpl'`, `'${sampleChunk.id}'`)\n    }\n\n    return new Uint8Array(sampleChunk.buffer)\n  }\n\n  /**\n   * Get the preset data from the chunk. This assumes the chunk is a LIST chunk containing the\n   * preset data sub-chunks.\n   */\n  public getPresetData(): PresetData {\n    if (!this.validMetaDataChunkId()) {\n      throw new ParseError('Unexpected chunk ID', `'LIST'`, `'${this.id}'`)\n    }\n\n    return {\n      presetHeaders: getPresetHeaders(this.subChunks[0]),\n      presetZones: getZones(this.subChunks[1], 'pbag'),\n      presetModulators: getModulators(this.subChunks[2], 'pmod'),\n      presetGenerators: getGenerators(this.subChunks[3], 'pgen'),\n      instrumentHeaders: getInstrumentHeaders(this.subChunks[4]),\n      instrumentZones: getZones(this.subChunks[5], 'ibag'),\n      instrumentModulators: getModulators(this.subChunks[6], 'imod'),\n      instrumentGenerators: getGenerators(this.subChunks[7], 'igen'),\n      sampleHeaders: getSampleHeaders(this.subChunks[8])\n    }\n  }\n}\n"],"names":["SF2Chunk","RIFFChunk","constructor","chunk","super","id","length","buffer","subChunks","__publicField","this","map","subChunk","validMetaDataChunkId","getMetaData","ParseError","info","reduce","target","SF_VERSION_LENGTH","getInt16","getString","ifil","INAM","version","soundEngine","isng","name","rom","irom","romVersion","iver","creationDate","ICRD","author","IENG","product","IPRD","copyright","ICOP","comments","ICMT","createdBy","ISFT","getSampleData","sampleChunk","Uint8Array","getPresetData","presetHeaders","getPresetHeaders","presetZones","getZones","presetModulators","getModulators","presetGenerators","getGenerators","instrumentHeaders","getInstrumentHeaders","instrumentZones","instrumentModulators","instrumentGenerators","sampleHeaders","getSampleHeaders"],"mappings":"0nBAYO,MAAMA,UAAiBC,EAMrB,WAAAC,CAAYC,GACjBC,MAAMD,EAAME,GAAIF,EAAMG,OAAQH,EAAMI,OAAQJ,EAAMK,WAH3BC,EAAAC,KAAA,aAKlBA,KAAAF,UAAYL,EAAMK,UAAUG,KAAKC,GAAa,IAAIZ,EAASY,IAClE,CAMQ,oBAAAC,GACN,MAAmB,SAAZH,KAAKL,EACd,CAEO,WAAAS,GACD,IAACJ,KAAKG,uBACR,MAAM,IAAIE,EAAW,sBAAuB,SAAU,IAAIL,KAAKL,OAGjE,MAAMW,EAAON,KAAKF,UAAUS,QAAgD,CAACC,EAAQf,KACnF,GAAiB,SAAbA,EAAME,IAA8B,SAAbF,EAAME,GAAe,CAE1C,GAAAF,EAAMG,SAAWa,EACnB,MAAM,IAAIJ,EAAW,yBAAyBZ,EAAME,iBAE/Ca,EAAAf,EAAME,IAA2B,GAAGF,EAAMiB,cAAcjB,EAAMiB,SAAS,IAAE,MAEhFF,EAAOf,EAAME,IAA2BF,EAAMkB,YAGzC,OAAAH,CAAA,GACN,CAAE,GAED,IAACF,EAAKM,KACF,MAAA,IAAIP,EAAW,qCAGnB,IAACC,EAAKO,KACF,MAAA,IAAIR,EAAW,qCAGhB,MAAA,CACLS,QAASR,EAAKM,KACdG,YAAaT,EAAKU,MAAQ,UAC1BC,KAAMX,EAAKO,KACXK,IAAKZ,EAAKa,KACVC,WAAYd,EAAKe,KACjBC,aAAchB,EAAKiB,KACnBC,OAAQlB,EAAKmB,KACbC,QAASpB,EAAKqB,KACdC,UAAWtB,EAAKuB,KAChBC,SAAUxB,EAAKyB,KACfC,UAAW1B,EAAK2B,KAEpB,CAMO,aAAAC,GACD,IAAClC,KAAKG,uBACR,MAAM,IAAIE,EAAW,sBAAuB,SAAU,IAAIL,KAAKL,OAG3D,MAAAwC,EAAcnC,KAAKF,UAAU,GAC/B,GAAmB,SAAnBqC,EAAYxC,GACd,MAAM,IAAIU,EAAW,0BAA2B,SAAU,IAAI8B,EAAYxC,OAGrE,OAAA,IAAIyC,WAAWD,EAAYtC,OACpC,CAMO,aAAAwC,GACD,IAACrC,KAAKG,uBACR,MAAM,IAAIE,EAAW,sBAAuB,SAAU,IAAIL,KAAKL,OAG1D,MAAA,CACL2C,cAAeC,EAAiBvC,KAAKF,UAAU,IAC/C0C,YAAaC,EAASzC,KAAKF,UAAU,GAAI,QACzC4C,iBAAkBC,EAAc3C,KAAKF,UAAU,GAAI,QACnD8C,iBAAkBC,EAAc7C,KAAKF,UAAU,GAAI,QACnDgD,kBAAmBC,EAAqB/C,KAAKF,UAAU,IACvDkD,gBAAiBP,EAASzC,KAAKF,UAAU,GAAI,QAC7CmD,qBAAsBN,EAAc3C,KAAKF,UAAU,GAAI,QACvDoD,qBAAsBL,EAAc7C,KAAKF,UAAU,GAAI,QACvDqD,cAAeC,EAAiBpD,KAAKF,UAAU,IAEnD"}