import{SoundFont3 as e}from"../soundFont3.js";import{writeSoundFont as r}from"./writeSoundFont.js";import{pcm16BufferToWav as t}from"./convert/writeWav.js";const o=async(o,a={bitrate:32,sampleRate:44100,oggCompressionAlgorithm:"vorbis"},n=`soundfont-${crypto.randomUUID()}`)=>{if("undefined"!=typeof document)throw Error("WebCodecs not supported yet.");const{existsSync:s,mkdirSync:i,readFileSync:m,rmdirSync:d,unlinkSync:c,writeFileSync:f}=await import("fs"),{execSync:p}=await import("child_process");s(n)||i(n);const g=structuredClone(o),h=Number(g.metaData.version);let u="wav",y=(e,r)=>t(e,r);h>=3&&h<4&&(u="ogg",y=(e,r)=>Buffer.from(r));const l=[];let $=Buffer.from("");return g.samples.map((e=>{const r=`${n}/${e.header.name}`,t=y(e.header.sampleRate,new Int16Array(e.data));f(`${r}.${u}`,t),p(`ffmpeg -y -i "${r}.${u}" -ar ${a.sampleRate} -ab ${a.bitrate}k -acodec lib${a.oggCompressionAlgorithm} "${r}.ogg"`,{stdio:"ignore"});const o=m(`${r}.ogg`);c(`${r}.wav`),c(`${r}.ogg`);const s=Buffer.from(new ArrayBuffer(2-o.byteLength%2));e.header.start=$.byteLength,e.header.end=e.header.start+o.byteLength,e.header.startLoop-=e.header.start,e.header.endLoop-=e.header.start,l.push(e.header),$=Buffer.concat([$,o,s])})),d(n),g.metaData.version="3.1",g.sampleData=new Int16Array($),g.presetData.sampleHeaders=l,new e(Buffer.from(r(g)))};export{o as toSoundFont3};
//# sourceMappingURL=toSoundFont3.js.map
