import{writeRiffSubChunk as e,writeRiffTopChunk as t}from"./writeRiffChunk.js";import{concatBuffer as n}from"../utils.js";const r=(e,t)=>{const r=(new TextEncoder).encode(e),a=t-r.byteLength;return a<0?r.slice(0,t):n(r,new ArrayBuffer(a))},a=a=>{let s=new Int8Array;{const t="phdr";let o=new Int8Array;a.presetHeaders.map((e=>{const t=r(e.name,20),a=new DataView(new ArrayBuffer(18));a.setUint16(0,e.preset,!0),a.setUint16(2,e.bank,!0),a.setUint16(4,e.bagIndex,!0),a.setUint32(6,e.library,!0),a.setUint32(10,e.genre,!0),a.setUint32(14,e.morphology,!0),o=n(o,n(t,a.buffer))}));const i=e(t,o);s=n(s,i)}{const t="pbag";let r=new Int8Array;a.presetZones.map((e=>{const t=new DataView(new ArrayBuffer(4));t.setInt16(0,e.generatorIndex,!0),t.setInt16(2,e.modulatorIndex,!0),r=n(r,t.buffer)}));const o=e(t,r);s=n(s,o)}{const t="pmod";let r=new Int8Array;a.presetModulators.map((e=>{const t=new DataView(new ArrayBuffer(10));t.setUint16(0,e.source.index,!0),t.setUint16(0,e.id,!0),t.setInt16(0,e.value,!0),t.setUint16(0,e.valueSource.index,!0),t.setUint16(0,e.transform,!0),r=n(r,t.buffer)}));const o=e(t,r);s=n(s,o)}{const t="pgen";let r=new Int8Array;a.presetGenerators.map((e=>{const t=new DataView(new ArrayBuffer(4));t.setUint16(0,e.id,!0);const a=void 0!==e.range,s=void 0!==e.value;if(a&&s)throw Error('Both "range" and "value" are defined in "pgen" when only one should be defined.');(a||s)&&(void 0!==e.range?(t.setUint8(2,e.range.lo),t.setUint8(3,e.range.hi)):void 0!==e.value&&t.setUint16(2,e.value,!0)),r=n(r,t.buffer)})),r=n(r,new ArrayBuffer(4));const o=e(t,r);s=n(s,o)}{const t="inst";let o=new Int8Array;a.instrumentHeaders.map((e=>{const t=r(e.name,20),a=new DataView(new ArrayBuffer(2));a.setUint16(0,e.bagIndex,!0),o=n(o,n(t,a.buffer))}));const i=e(t,o);s=n(s,i)}{const t="ibag";let r=new Int8Array;a.instrumentZones.map((e=>{const t=new DataView(new ArrayBuffer(4));t.setInt16(0,e.generatorIndex,!0),t.setInt16(2,e.modulatorIndex,!0),r=n(r,t.buffer)}));const o=e(t,r);s=n(s,o)}{const t="imod";let r=new Int8Array;a.instrumentModulators.map((e=>{const t=new DataView(new ArrayBuffer(10));t.setUint16(0,e.source.index,!0),t.setUint16(0,e.id,!0),t.setInt16(0,e.value,!0),t.setUint16(0,e.valueSource.index,!0),t.setUint16(0,e.transform,!0),r=n(r,t.buffer)}));const o=e(t,r);s=n(s,o)}{const t="igen";let r=new Int8Array;a.instrumentGenerators.map((e=>{const t=new DataView(new ArrayBuffer(4));t.setUint16(0,e.id,!0);const a=void 0!==e.range,s=void 0!==e.value;if(a&&s)throw Error('Both "range" and "value" are defined in "pgen" when only one should be defined.');(a||s)&&(void 0!==e.range?(t.setUint8(2,e.range.lo),t.setUint8(3,e.range.hi)):void 0!==e.value&&t.setUint16(2,e.value,!0)),r=n(r,t.buffer)}));const o=e(t,r);s=n(s,o)}{const t="shdr";let o=new Int8Array;a.sampleHeaders.map((e=>{const t=r(e.name,20),a=new DataView(new ArrayBuffer(26));a.setUint32(0,e.start,!0),a.setUint32(4,e.end,!0),a.setUint32(8,e.start+e.startLoop,!0),a.setUint32(12,e.start+e.endLoop,!0),a.setUint32(16,e.sampleRate,!0),a.setUint8(20,e.originalPitch),a.setInt8(21,e.pitchCorrection),a.setUint16(22,e.link,!0),a.setUint16(24,e.type,!0),o=n(o,n(t,a.buffer))}));const i=e(t,o);s=n(s,i)}return t("LIST","pdta",s)};export{a as writePresetDataChunk};
//# sourceMappingURL=writePresetDataChunk.js.map
